"""Collection classes for managing multiple tools.

Enhancements for OpenAI-compatible providers:
- Provide JSON Schemas for tools so models know required args.
- Fallback inference for `str_replace_editor`'s missing `command` arg
  (some providers emit partial arguments). This keeps the pipeline
  resilient without changing tool semantics.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Any

from anthropic.types.beta import BetaToolUnionParam

from computer_use_demo.providers import ToolSpec

from .base import (
    BaseAnthropicTool,
    ToolError,
    ToolFailure,
    ToolResult,
)

_DEFAULT_HOME = Path(os.getenv("HOME", "/home/agent"))
_DEFAULT_DESKTOP = _DEFAULT_HOME / "Desktop"
def _normalize_computer_tool_input(tool_input: dict[str, Any]) -> None:
    """Sanitize/complement computer tool arguments generated by non-Anthropic models."""

    def _pop_if_none(key: str) -> None:
        if tool_input.get(key) is None:
            tool_input.pop(key, None)

    action = tool_input.get("action")
    if isinstance(action, str):
        raw_action = action.strip().lower()
        action_aliases: dict[str, str] = {
            "click": "left_click",
            "single_click": "left_click",
            "doubleclick": "double_click",
            "tripleclick": "triple_click",
            "drag": "left_click_drag",
            "drag_and_drop": "left_click_drag",
            "mouse_move": "mouse_move",
            "move": "mouse_move",
            "move_mouse": "mouse_move",
            "press": "key",
            "press_key": "key",
            "keypress": "key",
            "type_text": "type",
            "input": "type",
            "sleep": "wait",
            "pause": "wait",
            "wait_for": "wait",
            "open": "type",
        }
        resolved_action = action_aliases.get(raw_action, raw_action)
        if resolved_action == "type" and not isinstance(tool_input.get("text"), str):
            resolved_action = "left_click"
        tool_input["action"] = resolved_action
    else:
        tool_input.pop("action", None)

    _pop_if_none("text")
    if "text" in tool_input and not isinstance(tool_input["text"], str):
        tool_input["text"] = str(tool_input["text"])

    _pop_if_none("key")
    if "key" in tool_input and not isinstance(tool_input["key"], str):
        tool_input["key"] = str(tool_input["key"])

    if "coordinate" in tool_input:
        coordinate = tool_input["coordinate"]
        if (
            not isinstance(coordinate, list)
            or len(coordinate) != 2
            or not all(isinstance(val, (int, float)) and val >= 0 for val in coordinate)
        ):
            tool_input.pop("coordinate", None)
        else:
            tool_input["coordinate"] = [int(round(val)) for val in coordinate]

    # Remove disallowed fields per action to satisfy tool validation
    act = tool_input.get("action")
    if isinstance(act, str):
        if act in {
            "type",
            "key",
            "wait",
            "hold_key",
            "screenshot",
            "cursor_position",
            "left_mouse_down",
            "left_mouse_up",
        }:
            tool_input.pop("coordinate", None)
        if act in {
            "screenshot",
            "cursor_position",
            "left_click",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "left_mouse_down",
            "left_mouse_up",
        }:
            tool_input.pop("text", None)
        if act in {"mouse_move", "left_click_drag"}:
            # These require coordinates; if missing or invalid, drop action to avoid hard failure
            if "coordinate" not in tool_input:
                tool_input.pop("action", None)

    if "scroll_amount" in tool_input:
        scroll_amount = tool_input["scroll_amount"]
        if not isinstance(scroll_amount, (int, float)) or scroll_amount < 0:
            tool_input.pop("scroll_amount", None)
        else:
            tool_input["scroll_amount"] = int(round(scroll_amount))

    if "duration" in tool_input:
        duration = tool_input["duration"]
        if not isinstance(duration, (int, float)) or duration < 0:
            tool_input.pop("duration", None)
        else:
            tool_input["duration"] = float(duration)

    if "scroll_direction" in tool_input:
        direction = tool_input["scroll_direction"]
        if isinstance(direction, str):
            direction = direction.lower().strip()
            if direction in {"up", "down", "left", "right"}:
                tool_input["scroll_direction"] = direction
            else:
                tool_input.pop("scroll_direction", None)
        else:
            tool_input.pop("scroll_direction", None)

    # Drop extraneous keys produced by some providers (e.g., "path")
    for key in list(tool_input.keys()):
        if tool_input[key] is None:
            tool_input.pop(key, None)
    tool_input.pop("path", None)


def _normalize_editor_tool_input(tool_input: dict[str, Any]) -> None:
    """Clean and normalise editor tool arguments emitted by OpenAI-style providers."""
    command = tool_input.get("command")
    if isinstance(command, str):
        normalized = command.strip().lower()
        command_aliases = {
            "open": "view",
            "read": "view",
            "display": "view",
            "write": "create",
        }
        tool_input["command"] = command_aliases.get(normalized, normalized)
    elif command is not None:
        tool_input["command"] = str(command)

    path_value = tool_input.get("path")
    if isinstance(path_value, str):
        cleaned = path_value.strip().replace("\\", "/")
        if ":" in cleaned[:3]:
            cleaned = cleaned.split(":", 1)[1]
        base: Path | None = None
        if cleaned.startswith("~/"):
            cleaned = cleaned[2:]
            base = _DEFAULT_HOME

        segments = [segment for segment in cleaned.split("/") if segment]
        resolved_path: Path
        if segments:
            lowered = [segment.lower() for segment in segments]
            if "desktop" in lowered:
                idx = lowered.index("desktop")
                desktop_tail = segments[idx + 1 :]
                resolved_path = _DEFAULT_DESKTOP.joinpath(*desktop_tail)
            elif base is not None:
                resolved_path = base.joinpath(*segments)
            else:
                resolved_path = Path("/") / Path("/".join(segments))
        else:
            resolved_path = _DEFAULT_DESKTOP

        tool_input["path"] = str(resolved_path)


class ToolCollection:
    """A collection of anthropic-defined tools."""

    def __init__(self, *tools: BaseAnthropicTool):
        self.tools = tools
        self.tool_map = {tool.to_params()["name"]: tool for tool in tools}

    def to_params(
        self,
    ) -> list[BetaToolUnionParam]:
        return [tool.to_params() for tool in self.tools]

    def to_specs(self) -> list[ToolSpec]:
        """Return provider-agnostic tool specifications."""
        specs: list[ToolSpec] = []
        for tool in self.tools:
            params = tool.to_params()
            name = params["name"]
            if name == "computer":
                tool_type = "computer_use"
            elif name == "bash":
                tool_type = "bash"
            elif name == "str_replace_editor":
                tool_type = "edit"
            else:
                tool_type = "generic"

            # Provide richer input schemas for providers that support it
            input_schema: dict[str, Any] = params.get("input_schema", {}) or {}
            description = params.get("description", "")

            if name == "computer":
                description = description or (
                    "Control the remote desktop by moving the mouse, clicking, typing, "
                    "scrolling, or taking screenshots."
                )
                input_schema = {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "enum": [
                                "mouse_move",
                                "left_click",
                                "right_click",
                                "middle_click",
                                "double_click",
                                "triple_click",
                                "left_click_drag",
                                "screenshot",
                                "cursor_position",
                                "key",
                                "type",
                                "left_mouse_down",
                                "left_mouse_up",
                                "scroll",
                                "hold_key",
                                "wait",
                            ],
                            "description": "Desktop action to perform.",
                        },
                        "coordinate": {
                            "type": "array",
                            "items": {"type": "integer"},
                            "minItems": 2,
                            "maxItems": 2,
                            "description": "Screen coordinate [x, y] in pixels for mouse actions.",
                        },
                        "text": {
                            "type": "string",
                            "description": "Text to type or key chord (e.g., 'Ctrl+c').",
                        },
                        "scroll_direction": {
                            "type": "string",
                            "enum": ["up", "down", "left", "right"],
                            "description": "Scroll direction when action is 'scroll'.",
                        },
                        "scroll_amount": {
                            "type": "integer",
                            "minimum": 0,
                            "description": "Number of scroll ticks when action is 'scroll'.",
                        },
                        "duration": {
                            "type": "number",
                            "minimum": 0,
                            "description": "Seconds to wait or hold a key for applicable actions.",
                        },
                        "key": {
                            "type": "string",
                            "description": "Key to press when action is 'hold_key'.",
                        },
                    },
                    "required": ["action"],
                }
            elif name == "bash" and not input_schema:
                description = description or "Execute shell commands in a persistent bash session."
                input_schema = {
                    "type": "object",
                    "properties": {
                        "command": {"type": "string", "description": "Shell command to run"},
                        "restart": {"type": "boolean", "description": "Restart the bash session"},
                    },
                }

            if name == "str_replace_editor" and not input_schema:
                description = description or (
                    "View, create, or edit files (string replace, insert, undo)."
                )
                input_schema = {
                    "type": "object",
                    "properties": {
                        "command": {
                            "type": "string",
                            "enum": [
                                "view",
                                "create",
                                "str_replace",
                                "insert",
                                "undo_edit",
                            ],
                            "description": "Editor subcommand to run",
                        },
                        "path": {"type": "string", "description": "Absolute file path"},
                        "file_text": {"type": "string", "description": "Initial content when creating a file"},
                        "view_range": {
                            "type": "array",
                            "items": {"type": "integer"},
                            "minItems": 2,
                            "maxItems": 2,
                            "description": "[start_line, end_line] or [start_line, -1]",
                        },
                        "old_str": {"type": "string"},
                        "new_str": {"type": ["string", "null"]},
                        "insert_line": {"type": "integer"},
                    },
                    "required": ["command", "path"],
                }

            specs.append(
                ToolSpec(
                    name=name,
                    description=description,
                    input_schema=input_schema,
                    tool_type=tool_type,
                    metadata={"anthropic_params": params},
                )
            )
        return specs

    async def run(self, *, name: str, tool_input: dict[str, Any]) -> ToolResult:
        tool = self.tool_map.get(name)
        if not tool:
            return ToolFailure(error=f"Tool {name} is invalid")
        try:
            if name == "str_replace_editor":
                _normalize_editor_tool_input(tool_input)
                if "command" not in tool_input:
                    if tool_input.get("file_text") is not None:
                        tool_input["command"] = "create"
                    elif tool_input.get("old_str") is not None:
                        tool_input["command"] = "str_replace"
                    elif tool_input.get("insert_line") is not None:
                        tool_input["command"] = "insert"
                    else:
                        tool_input["command"] = "view"
                path = tool_input.get("path")
                if isinstance(path, Path):
                    tool_input["path"] = str(path)
                elif isinstance(path, str) and not path.startswith("/"):
                    tool_input["path"] = str(Path("/") / path)
            elif name == "computer":
                _normalize_computer_tool_input(tool_input)

            return await tool(**tool_input)
        except ToolError as e:
            return ToolFailure(error=e.message)
        except TypeError as exc:
            # Catch plain Python signature errors (common when providers emit partial args).
            return ToolFailure(error=f"{name} invocation failed: {exc}")
